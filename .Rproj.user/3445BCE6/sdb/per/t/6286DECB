{
    "contents" : "---\ntitle: \"Time Series\"\nauthor: \"John Tipton\"\ndate: \"August 24, 2015\"\noutput: \"pdf_document\"\n---\n```{r}\n## Load R packages and define helper functions\nlibrary(ggplot2, quietly = TRUE)\nlibrary(reshape2, quietly = TRUE)\nlibrary(grid, quietly = TRUE)\n## Function to plot multiple ggplots on the same image\nmultiplot <- function(..., plotlist=NULL, cols) {\n  require(grid)\n\t\n\t# Make a list from the ... arguments and plotlist\n\tplots <- c(list(...), plotlist)\n\t\n\tnumPlots = length(plots)\n\t\n\t# Make the panel\n\tplotCols = cols                       # Number of columns of plots\n\tplotRows = ceiling(numPlots/plotCols) # Number of rows needed, calculated from # of cols\n\t\n\t# Set up the page\n\tgrid.newpage()\n\tpushViewport(viewport(layout = grid.layout(plotRows, plotCols)))\n\tvplayout <- function(x, y)\n\t\tviewport(layout.pos.row = x, layout.pos.col = y)\n\t\n\t# Make each plot, in the correct location\n\tfor (i in 1:numPlots) {\n\t\tcurRow = ceiling(i/plotCols)\n\t\tcurCol = (i-1) %% plotCols + 1\n\t\tprint(plots[[i]], vp = vplayout(curRow, curCol ))\n\t}\t\n}\n\n##\n## function to simulate time series\n##\n\nsimTimeSeries <- function(t, N, mu, s, phi){\n  if(N == 1){\n    y <- rep(0, t)                                      ## initialize container\n    y[1] <- mu[1] + rnorm(1, 0, s)                      ## initailize time series at time 1\n    for(i in 2:t){\n      epsilon <- rnorm(1, 0, s)                         ## independent random error\n      y[i] <- mu[i] + phi * y[i-1] + epsilon            ## autoregressive model\n    }\n  } else {\n    y <- matrix(0, t, N)                                ## initialize container\n    y[1, ] <- mu[1] + rnorm(N, 0, s)                    ## initailize time series at time 1\n    for(i in 2:t){\n      epsilon <- rnorm(N, 0, s)                         ## independent random error\n      y[i, ] <- mu[i] + phi * y[i-1, ] + epsilon        ## autoregressive model\n    }\n  }\n  return(y)\n}\n\n```\nFirst, we start with the canonical difference equation for the time series autoregressive model of order 1 (AR(1))\n\\begin{align}\n\\label{ar}\ny_t & = \\mu_t + \\phi y_{t-1} + \\epsilon_t\n\\end{align}\nwhere the time series observations for times $t = 1, \\ldots, T$ are given by the vector $\\mathbf{y} = \\left( y_1, \\ldots, y_T \\right)$ where $y_t$ is the observation of the time serise at time $t$. The vector $\\boldsymbol{\\mu}$ is the temporal mean with $\\mu_t$ representing the mean of the time series at time $t$. Often the mean is a trend or seasonal component like in the example below. The autoregressive parameter $\\phi$ controls the strength of autocorrelation in the time series with $-1 < \\phi < 1$ and the random error $\\epsilon_t \\sim N(0, \\sigma^2)$ is independent for different times (i.e. the covariance $\\mathrm{Cov}(\\epsilon_t, \\epsilon_{t+k}) = 0$ for $k \\neq 0$). \n\n# Lets simulate some data here\n```{r simData}\nN <- 1                              ## pick the number of time series\nt <- 1000                           ## pick a time series length\nmu <- rep(0, t)\n# mu <- sin(2 * pi * (1:t)/t)         ## pick a mean\ns <- 0.25                           ## pick standard deviation\nphi <- 0.90                         ## pick autocorrelation parameter\n\ny <- simTimeSeries(t, N, mu, s, phi)\nggplot(data=data.frame(y=y, t=1:t), aes(y=y, x=t)) + \n  geom_line(alpha=1, colour=\"darkgrey\") + \n  ggtitle(\"Plot of a single time series\") + \n  theme(plot.title = element_text(size=18))\n\n```\n\nThe expected value $\\mathrm{E}(y_t)$ of the time series at time $t$ is \n\\begin{align*}\n\\mathrm{E}(y_t) & = \\mathrm{E}(\\phi y_{t-1}) + \\mathrm{E}(\\epsilon_t) \\\\\n& = \\phi \\mathrm{E}(y_{t-1}) + 0\n\\end{align*}\nwhere, assuming a constant mean $\\mu$ accross time we have\n\\begin{align*}\n\\mathrm{E}(y_t) & = \\phi \\mathrm{E}(y_{t-1})\\\\\n\\rightarrow\n\\mathrm{E}(y_t) (1 - \\phi) & = 0\\\\\n\\rightarrow\n\\mathrm{E}(y_t) & = 0\\\\\n\\end{align*}\nand assuming constant variance through time, the variance is \n\\begin{align*}\n\\mathrm{Var}(y_t) & = \\mathrm{Var}(\\phi y_{t - 1} + \\epsilon_t) \\\\\n& = \\mathrm{Var}(\\phi y_{t - 1}) + \\mathrm{Var}(\\epsilon_t) + 2 \\mathrm{Cov}(\\phi y_{t - 1}, \\epsilon_t) \\\\\n& = \\phi^2 \\mathrm{Var}(y_{t - 1}) + \\sigma^2  + 0 \\\\\n\\end{align*}\n\nThen using our modeling assumption $\\mathrm{Var}(y_t) = \\mathrm{Var}(y_{t-1})$,\n\\begin{align*}\n\\mathrm{Var}(y_t) - \\phi^2 \\mathrm{Var}(y_t) & = \\sigma^2 \\\\\n% & = \\phi^2 \\left(\\phi^2 \\mathrm{Var}(y_{t - 2}) + \\sigma^2 \\right) + \\sigma^2 \\\\\n% & = \\vdots \\\\\n\\end{align*}\ngives the solution $\\mathrm{Var}(y_t) = \\frac{\\sigma^2}{1 - \\phi^2}$.\n```{r properties}\nN <- 10                               ## replicates N\ny <- simTimeSeries(t, N, mu, s, phi)  ## simulate time series\n## legend() add in legend for mean and y label\n## Notice that the y axis is shrunk to 0\n\n## \n\nmean_y <- apply(y, 1, mean)    ##  calculate the mean\nvar_y <-apply(y, 1, var)       ##  calculate the variance\nsd_y <- apply(y, 1, sd)        ##  calculate the standard deviation\n\ntime_data <- data.frame(y=y, t=1:t)\nmelt_time <- melt(time_data, id=\"t\")                        \nsummary_data <- data.frame(mean_y=mean_y, var_y=var_y, sd_y=sd_y, mu=mu, \n                        s=s, t=1:t)\n\n\n## plot time series with mean and variance\n\n\nplot_mean <- ggplot(data = melt_time, aes(y=value, x=t)) + \n  geom_line(alpha=1, colour=\"darkgrey\") + \n  geom_line(data=summary_data, aes(y=mean_y, x=t, colour=\"empirical\"), \n            alpha=0.75) + \n  geom_line(data=summary_data, aes(y=mu, x=t, colour=\"truth\"), alpha=0.75, \n            lty=2, lwd=2) + \n  scale_colour_manual(\"Mean\", labels=c(\"empirical\", \"truth\"), \n                      values=c(\"empirical\"=\"red\",\"truth\"=\"blue\")) + \n  scale_y_continuous(\"y\") + scale_x_continuous(\"t\") +\n  ggtitle(paste(min(N, 10), \n                \"time series with empircal and true mean\")) +\n  theme(plot.title = element_text(size=18))\n \nplot_sd <- ggplot(data = melt_time, aes(y=value, x=t)) + \n  geom_line(alpha=1, colour=\"darkgrey\") + \n  geom_line(data=summary_data, aes(y=sd_y, x=t, colour=\"empirical\"), \n            alpha=0.75) + \n  geom_line(data=summary_data, aes(y=s, x=t, colour=\"truth\"), alpha=0.75, \n            lty=2, lwd=2) + \n  scale_colour_manual(\"Std Dev\", labels=c(\"empirical\", \"truth\"), \n                      values=c(\"empirical\"=\"red\",\"truth\"=\"blue\")) + \n  scale_y_continuous(\"y\") + scale_x_continuous(\"t\") + \n  ggtitle(paste(min(N, 10), \n                \"time series with empirical and true standard deviation\")) + \n  theme(plot.title = element_text(size=18))\n\n## Plot using multiplot\nmultiplot(plot_mean, plot_sd, cols=1)\n```\n\nThe covariance between observations $\\mathrm{Cov}(y_t, y_{t+k})$ at times $k$ lags apart (assuming without loss of generality that $k>0$) is\n\\begin{align*}\n\\mathrm{Cov}(y_t, y_{t+k}) & = \\mathrm{E}(y_t y_{t+k}) - \\mathrm{E}(y_t) \\mathrm{E}(y_{t+k}) \\\\ \n& = \\mathrm{E}(y_t (\\phi y_{t+k-1} + \\epsilon_{t+k})) - 0 \\\\\n& = \\mathrm{E}(\\phi y_t y_{t+k-1}) + \\mathrm{E}(y_t \\epsilon_{t+k}) \\\\\n& = \\mathrm{E}(\\phi y_t y_{t+k-1}) + \\mathrm{E}(y_t) \\mathrm{E}(\\epsilon_{t+k})\\\\\n& = \\mathrm{E}(\\phi y_t y_{t+k-1}) + 0 \\\\\n& = \\mathrm{E}(y_t (\\phi y_{t+k-2} + \\epsilon_{t+k-1})) \\\\\n& = \\vdots \\\\\n& = \\phi^{k} \\mathrm{E}(y_t^2) \\\\\n& = \\phi^{k} \\frac{\\sigma^2}{1 - \\phi^2}. \\\\\n\\end{align*}\n\n```{r covariance}\n## detrend the time series <- if you set mu = something other than 0\n# y_detrend <- y-mu\n# ggplot(data=melt(data.frame(y=y_detrend, t=1:t), id=\"t\"), aes(y=value, x=t)) + \n#   geom_line(alpha=1, colour=\"darkgrey\") + \n#   scale_y_continuous(\"y\") + scale_x_continuous(\"t\") +\n#   ggtitle(paste(min(N, 10), \n#                 \"time series with trend removed\")) + \n#   theme(plot.title = element_text(size=18))\n\ncovariances <- matrix(0, min(t, 20), N)\nfor(i in 1:N){\n    for(k in 1:min(t, 20)-1){\n      covariances[k+1, i] <- cov(y[1:(t-k), i], y[1:(t-k) + k, i])\n  }\n}\n\ncov_data <- data.frame(y=covariances, t=1:20)\nmelt_cov <- melt(cov_data, id=\"t\")\nggplot(data = melt_cov, aes(y=value, x=t)) + \n  geom_line(data=melt_cov, aes(y=value, x=t, group=variable, colour=\"empirical\"), alpha=1) + \n  geom_line(data=data.frame(y=s^2/(1-phi^2) * phi^(0:min(t,20)), x=0:min(t, 20)), aes(y=y, x=x, colour=\"truth\"), \n            alpha=0.75) + \n  scale_colour_manual(\"Autocovariance\", labels=c(\"empirical\", \"true\"), \n                      values=c(\"empirical\"=\"darkgrey\",\"truth\"=\"blue\")) + \n  scale_y_continuous(\"autocovariance\") + scale_x_continuous(\"lag\") + \n  ggtitle(paste(min(N, 10), \n                \"empirical autocovariance functions\")) + \n  theme(plot.title = element_text(size=18))\n```\n\nThus, knowing the mean, variance, and covariance at each time $t$ and each lag $k$, we can write the autoregressive model (\\ref{ar1}) as \n\\begin{align}\n\\label{var}\n\\mathbf{y} & = \\boldsymbol{\\mu} + \\boldsymbol{\\eta}\n\\end{align}\nwhere $\\mathbf{\\mu} = \\left(0, \\ldots, 0 \\right)$ and $\\eta ~ \\mbox{N}\\left( \\mathbf{0}, \\boldsymbol{\\Sigma} \\right)$ where\n\\begin{align*}\n\\boldsymbol{\\Sigma} & = \\frac{\\sigma^2}{1 - \\phi^2} \\left(\\begin{pmatrix}\n1 & \\phi & \\phi^2 & \\phi^3 & \\cdots & \\phi^{T-1}\\\\\n\\phi & 1 & \\phi & \\phi^2 & \\cdots & \\phi^{T-2}\\\\\n\\phi^2 & \\phi & 1 & \\phi & \\cdots & \\phi^{T-3} \\\\\n\\phi^3 & \\phi^2 & \\phi & 1 & \\cdots & \\phi^{T-4} \\\\\n\\vdots & \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n\\phi^{T-1} & \\phi^{T-2} & \\phi^{T-3} & \\phi^{T-4} & \\cdots & 1\n\\end{pmatrix} \\right)\n\\end{align*}\n\n```{r vectorTimeSeries}\nSigma <- s^2 / (1 - phi^2) * toeplitz(phi^(0:(t-1)))\nlibrary(mvtnorm)\ny_vec <- t(rmvnorm(N, mu, Sigma))\n\nvec_data <- data.frame(y=y_vec, t=1:t)\nmelt_vec <- melt(vec_data, id=\"t\")                        \n\n\nggplot(data = melt_vec, aes(y=value, x=t)) + \n  geom_line(alpha=1, colour=\"darkgrey\") + \n  scale_y_continuous(\"y\") + scale_x_continuous(\"t\") + \n  ggtitle(paste(min(N, 10), \n                \"time series simulated as a vector\")) + \n  theme(plot.title = element_text(size=18))\n```\n\nTypically, the distributions of interest in a time series model are the forecast distribution (used for prediction) and the smoothing distribution (used for estimation of parameters). The forecast distribution at time $\\tau + 1$ consists of knowledge of all of the observations of the time series up to the time $\\tau$ $y_{1:{\\tau}} = (y_1, \\ldots, y_{\\tau})$ given by\n\\begin{align*}\n[y_{\\tau+1} | y_{1:{\\tau}}] & = [y_{\\tau+1} | y_{\\tau}]\n\\end{align*}\nby the Markov assumption in the autoregressive model. Then, the one step ahead expected forecast is \n\\begin{align*}\n\\mathrm{E}(y_{\\tau+1} | y_{1:{\\tau}}) & = \\mathrm{E}(y_{\\tau+1} | y_{\\tau}) \\\\\n& = \\mathrm{E}(\\phi y_{\\tau} + \\epsilon_{\\tau + 1} | y_{\\tau}) \\\\\n& = \\mathrm{E}(\\phi y_{\\tau}| y_{\\tau}) + \\mathrm{E}(\\epsilon_{\\tau+1} | y_{\\tau}) \\\\\n& \\phi y_{\\tau} + 0. \\\\\n\\end{align*}\nThe $k$ step ahead expected forecast is calculated by using a recursive formula of the equation above where $\\mathrm{E}(y_{\\tau + k} | y_{1:{\\tau}}) = \\phi^k y_{\\tau}$.\n\nLikewise, the one step ahead forecast variance is  \n\\begin{align*}\n\\mathrm{Var}(y_{\\tau+1} | y_{1:{\\tau}}) & = \\mathrm{Var}(y_{\\tau+1} | y_{\\tau}) \\\\\n& = \\mathrm{Var}(\\phi y_{\\tau} + \\epsilon_{\\tau+1} | y_{\\tau}) \\\\\n& = \\phi^2 \\mathrm{Var}(y_{\\tau}| y_{\\tau}) + 2 \\mathrm{Cov}(\\phi y_{\\tau}, \\epsilon_{\\tau+1}| y_{\\tau}) + \\mathrm{Var}(\\epsilon_{\\tau+1} | y_{\\tau}) \\\\\n& =  0 + 0 + \\sigma^2.\n\\end{align*}\nThe $k$ step ahead forecast variance can also be calcuated recursively giving $\\mathrm{Var}(y_{\\tau+k} | y_{1:{\\tau-1}}) = \\sum_{i=1}^k \\phi^{2(i-1)} \\sigma^2$.\n\n",
    "created" : 1440435510626.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2098871488",
    "id" : "6286DECB",
    "lastKnownWriteTime" : 1440632443,
    "path" : "~/basisPaper/timeSeries.Rmd",
    "project_path" : "timeSeries.Rmd",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_markdown"
}